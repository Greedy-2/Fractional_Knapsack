# Fractional_Knapsack


# 과제: 그리디 알고리즘 자유주제



### 1. 부분 배낭 문제
![Fractional_Kanpsack](https://dudri63.github.io/image/algo14-1.png)

배낭(Knapsack) 문제는 n개의 물건이 있고, 각 물건은 무게와 가치를 가지고 있을 때, 최대의 가치를 갖도록 한정된 용량의 배낭에 넣을 물건들을 정하는 문제이다.
원래의 배낭 문제는 물건을 통째로 배낭에 넣어야 하는 것에 반해,
부분 배낭(Fractional Knapsack) 문제는 물건을 부분적으로 담는 것이 허용 된다.

부분 배낭 문제에서는 물건을 부분적으로 배낭에 담을 수 있으므로, 최적해을 위해서 ‘욕심을
내어’ 단위 무게당 가장 값나가는 물건을 배낭에 넣고, 계속해서 그 다음으로 값나가는 물건
을 넣는다. 그런데 만일 그 다음으로 값나가는 물건을 ‘통째로’ 배낭에 넣을 수 없게 되면, 배낭
에 넣을 수 있을 만큼만 물건을 부분적으로 배낭에 담도록 한다.


### 2. 알고리즘

FractionalKnapsack
입력: n개의 물건, 각 물건의 무게와 가치, 배낭의 용량 C
출력: 배낭에 담은 물건 리스트 L과 배낭에 담은 물건 가치의 합 v

1.   각 물건에 대해 단위 무게 당 가치를 계산한다.
2.   물건들을 단위 무게 당 가치를 기준으로 내림차순으로 정렬하고, 정렬된 물건 리스트를 S라고 하자.
3.   L=∅, w=0, v=0 
// L은 배낭에 담을 물건 리스트, w는 배낭에 담긴 물건들의 무게의 합, v는 배낭에 담긴 물건들의 가치의 합
4.   S에서 단위 무게 당 가치가 가장 큰 물건 x를 가져온다
5.   while ( (w+x의 무게) ≤ C ) { 
6.   x를 L에 추가시킨다.
7.   w = w+x의 무게
8.   v = v+x의 가치
9.   x를 S에서 제거한다.
10.  S에서 단위 무게 당 가치가 가장 큰 물건 x를 가져온다.
     }
     
11.  if ((C-w) > 0) { // 배낭에 물건을 부분적으로 담을 여유가 있으면 
12. 	물건 x를 (C-w)만큼만 L에 추가한다. 
13. 	v = v +(C-w)만큼의 x의 가치
      }
14.  return L, v


### 3. 시간복잡도

Line 1
n개의 물건 각각의 단위 무게 당 가치를 계산하는 데는 O(n) 시간 걸린다.
Line 2
물건의 단위 무게 당 가치에 대해서 내림차순으로 정렬하기 위해 O(nlogn) 시간이 걸린다.
Line 5-10
while-루프의 수행은 n번을 넘지 않으며, 루프 내부의 수행은 O(1) 시간이 걸린다. 
Line 11-14
각각 O(1) 시간 걸린다.

알고리즘의 시간복잡도는 O(n)+O(nlogn)+nxO(1)+O(1) = O(nlogn)이다.
